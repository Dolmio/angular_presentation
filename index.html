<!DOCTYPE html>
<html>
  <head>
    <title>Screenshots</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <link rel="stylesheet" href="css/style.css" type="text/css">
    <link rel="stylesheet" href="syntaxhighlighter/shThemeDefault.css" type="text/css">
    <script src="js/jquery-1.7.min.js"></script>
    <script src="js/angular-1.0.0rc8.min.js"></script>
    <script src="js/slidedeck.js"></script>
    <script src="js/dom.js"></script>
    <script src="js/presentation.js"></script>
    <script src="js/keyboard.js"></script>
    <script src="syntaxhighlighter/shCore.js"></script>
    <script src="syntaxhighlighter/shBrushJScript.js"></script>
    <script src="syntaxhighlighter/shBrushXml.js"></script>
    <script>
      SyntaxHighlighter.all();
      angular.module('AppModule',
        ['PresentationModule', 'KeyboardModule', 'SlideDeckModule']);
    </script>
  </head>
  <body
    ng-app="AppModule"
    ng-controller="PresentationController"
    keyboard-left="previous()"
    keyboard-right="next()"
    keyboard-pageUp="previous()"
    keyboard-pageDown="next()">

    <div id="intro">
      <h1>Screenshots</h1>
      <h2>
        Elliott Sprehn
      </h2>
      <h3 ng:hide="isInside()">
          <a href="http://elliottsprehn.com/@">@ElliottZ</a> /
          <a href="http://elliottsprehn.com/+">http://elliottsprehn.com/+</a>
      </h3>
    </div>

    <p id="counter" ng-show="isInside()">
      <a href="#/slides/1">&laquo;</a>
      {{activeSlide + 1}} / {{totalSlides}}
      <a href="#/slides/{{totalSlides}}">&raquo;</a>
    </p>

    <slide-deck current="activeSlide" total="totalSlides">

      <slide>
        <h2>What is Google Feedback ?</h2>
        <p>
          <img src="images/describe.png">
        </p>
      </slide>

      <slide>
        <h2>Screenshots in JavaScript (on the web)</h2>
        <p>
          <img src="images/preview.png" width="760">
        </p>
      </slide>

      <!--
        * Feedback is all about not asking users survey questions
        * Screenshot is super important
      -->
      <slide>
        <h2>Why screenshots</h2>
        <ul>
          <li>More useful feedback

          <li>Users write bad descriptions

          <li>Annotations show location of issues
        </ul>
      </slide>

      <!--
        * Google has complicated ACLs, server side rendering not easy
        * Blackout must be client side
        * Server side rendering = lots of resources
        * JS is cross platform
      -->
      <slide>
        <h2>Why client side</h2>
        <ul>
          <li>Privacy

          <li>Blackouts

          <li>Scalability

          <li>Cross platform
        </ul>
      </slide>

      <!--
        * Native API for screenshots
        * Users don't install things (or can't)
        * Getting users to update extensions is worse
        * Different JS for each browser extension, C++ for IE
      -->
      <slide>
        <h2>What about extensions</h2>
        <ul>
          <li>Angry users don't install things

          <li>Lots of browsers to support

          <li>Policies prevent installs
        </ul>
      </slide>

      <!--
        * Insecure domain so we can support untrusted user uploaded content
      -->
      <slide>
        <h2>Feedback internals</h2>
        <p>
          <img src="images/feedback-arch.png" height="550">
        </p>
      </slide>

      <!--
        * Clone the whole document
        * Make it stop changing
        * Lets user annotate
        * Stabilize rendering
        * "Frozen" appearance
      -->
      <slide>
        <h2>Clone the page</h2>
        <p>
          <img src="images/zombie-page.png" width="850">
        </p>
      </slide>

      <slide class="big-code">
        <h2>Measuring text</h2>
        <script type="syntaxhighlighter" slide-code>
          <p>
            <gft>Hello world.</gft>
          </p>
        </script>

        <h3>- OR -</h3>

        <script type="syntaxhighlighter" slide-code="js">
          var range = document.createRange();
          range.selectNode(textNode);
          var rect =
              range.getBoundingClientRect();
        </script>
      </slide>

      <slide>
        <h2>Proxy and serialize images</h2>
        <ul>
          <li>Proxy cross domain images

          <li>Use an iframe on the proxy domain

          <li>Serialize same domain images

          <li><code>postMessage()</code> data urls
        </ul>
      </slide>

      <!--
        * This is how we think of a page when authoring
        * Not how we think of it when styling
      -->
      <slide>
        <h2>Element tree</h2>
        <p>
          <img src="images/element-tree.png" height="550">
        </p>
      </slide>

      <!--
        * Separate renderers for different things: Frames, text, form controls,
        * Order of the tree can be different based on z-index and positioning
        * Collect commands with getBoundingClientRect offsetTop + offsetLeft
        * Gotcha: Apply offsets inside frames
      -->
      <slide>
        <h2>Render tree</h2>
        <p>
          <img src="images/render-tree.png" height="550">
        </p>
      </slide>

      <!--
        * Optimization: Only draw things inside the viewport
        * Small subset of the canvas API: drawText, drawRect, ...
      -->
      <slide>
        <h2>Create primitive commands</h2>
        <p>
          <img src="images/page-blocks.png" width="850">
        </p>
      </slide>

      <!--
        * Lots of JSON to send through postMessage()
      -->
      <slide>
        <h2>Serialize commands</h2>
        <script type="syntaxhighlighter" slide-code="js">
          [
            {
              "command": "pushClip",
              "args": [0, 0, 8, 8]
            },
            {
              "command": "drawText",
              "args": [10, 10, "Hello World", "red"]
            },
            {
              "command": "drawRect",
              "args": [10, 10, 20, 20, "red"]
            }
          ]
        </script>
      </slide>

      <!--
        * More compact and much faster
        * Fewer string allocations
        * Much less JSON
      -->
      <slide>
        <h2>Serialized commands (2)</h2>
        <script type="syntaxhighlighter" slide-code="js">
          [
            // Command 1 is pushClip
            [1, [0, 0, 8, 8]],

            // Command 10 is drawText
            [10, [10, 10, "Hello World"]],

            // Command 13 is drawRect
            [13, [10, 10, 20, 20, "red"]],

            // Command 2 is popClip
            [2],
          ]
        </script>
      </slide>

      <!--
        * Remove expensive commands like opacity and stacking contexts
        * Remove commands that do nothing like control commands
      -->
      <slide>
        <h2>Optimize commands</h2>
        <script type="syntaxhighlighter" slide-code="js">
          [
            // Nothing to draw
          ]
        </script>
      </slide>

      <!--
        * JPEG Encoder too slow in everything but Chrome
        * Native support in most browsers now
        * IE users unfortunately have a poor experience
      -->
      <slide>
        <h2>Image compression</h2>
        <ul>
          <li>JPEG Encoder in JS (Adobe)

          <li>toDataURL('image/jpeg', 0.2)
        </ul>
      </slide>

      <slide class="interlude">
        <h2></h2>
        <h3>
          Algorithms!
        </h3>
      </slide>

      <!--
        * The most awesome of algorithms..
        * No real recursion
        * Running commands is fast (not even async executed)
        * Slam the GPU (3k+ commands in some products)
      -->
      <slide>
        <h2>Async Executor</h2>
        <p>
          <img src="images/executor-flow.png" height="520">
        </p>
      </slide>

      <slide>
        <h2>AsyncExecutor#execute()</h2>
        <script type="syntaxhighlighter" slide-code="js">
          Executor.prototype.execute = function(fn) {
            // quantumLength is length of a time slice
            var end = Date.now() + this.quantumLength;
            while (isFunction(fn) && Date.now() < end) {
              fn = fn();
            }
            if (isFunction(fn)) {
              var next = this.execute.bind(this, fn);
              setTimeout(next, 0);
            }
          };
        </script>
      </slide>

      <slide>
        <h2>Async drawing</h2>
        <script type="syntaxhighlighter" slide-code="js">
          var i = 0;
          var commands = ...;

          function next() {
            if (i >= commands.length) return;

            executeDrawingCommand(commands[i++]);

            return next;
          }

          executor.execute(next);
        </script>
      </slide>

      <!--
        * The most awesome of algorithms..
        * No real recursion
      -->
      <slide>
        <h2>Async DOM Traversal</h2>
        <script type="syntaxhighlighter" slide-code="js">
          function traverse(element, callback) {
            process(element);

            function next(child) {
              if (!child) return callback;
              return traverse(child, function() {
                return next(child.nextElementSibling);
              });
            }

            return function() {
              return next(element.firstElementChild);
            };
          }
        </script>
      </slide>

      <!--
        * More efficient
        * Easier to understand what the code is doing
      -->
      <slide>
        <h2>Async DOM Traversal (2)</h2>
        <script type="syntaxhighlighter" slide-code="js">
          var i = 0;
          var elements = document.querySelector('*');

          function traverse() {
            if (i >= elements.length) return;

            // process could be Clone(),
            // Serialize(), or CreateRenderer()
            process(elements[i++]);

            return traverse;
          }
        </script>
      </slide>

      <slide>
        <h2>AsyncExecutor#forEach()</h2>
        <script type="syntaxhighlighter" slide-code="js">
          Executor.prototype.forEach =
              function(array, fn) {

            var i = 0;
            this.execute(function next() {
              if (i >= array.length) return;

              fn(array[i++]);

              return next;
            });
          };
        </script>
      </slide>

      <slide>
        <h2>Async DOM Traversal (3)</h2>
        <script type="syntaxhighlighter" slide-code="js">
          var executor = new Executor();
          executor.quantumLength = 16;

          var elements = document.querySelector('*');
          executor.forEach(elements, function(element) {
            // do something with the element...
          });
        </script>
      </slide>

      <slide>
        <h2>Memory issues</h2>
        <ul>
          <li>14MB of JSON

          <li>Massive data URLs

          <li>1GB buffer allocations (canvas)

          <li>Cache as much as possible
        </ul>
      </slide>

      <slide>
        <h2>Performance issues</h2>
        <ul>
          <li>Opacity is super slow

          <li>Use two modes: compute &rarr; draw

          <li>Impose deadlines
        </ul>
      </slide>

      <slide>
        <h2>Why deadlines</h2>
        <ul>
          <li>Abort slow async tasks

          <li>FF13, Chrome, Safari 5.1 are fast

          <li>IE8 and Firefox 3 are super slow

          <li>IE9 is (somewhat) better
        </ul>
      </slide>

      <slide>
        <h2>Similar projects</h2>
        <ul>
          <li><a href="http://html2canvas.hertzen.com/">html2canvas</a> (Niklas von Hertzen)

          <li><a href="https://github.com/jankuca/dom-panda">DOM Panda</a> (Jan Kuča)
        </ul>
      </slide>

    </slide-deck>

  </body>
</html>